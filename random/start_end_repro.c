// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

static bool write_file(const char* file, const char* what, ...)
{
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);
	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		int err = errno;
		close(fd);
		errno = err;
		return false;
	}
	close(fd);
	return true;
}

static int inject_fault(int nth)
{
	int fd;
	fd = open("/proc/thread-self/fail-nth", O_RDWR);
	if (fd == -1)
	exit(1);
	char buf[16];
	sprintf(buf, "%d", nth + 1);
	if (write(fd, buf, strlen(buf)) != (ssize_t)strlen(buf))
	exit(1);
	return fd;
}

static void setup_fault()
{
	static struct {
		const char* file;
		const char* val;
		bool fatal;
	} files[] = {
	    {"/sys/kernel/debug/failslab/ignore-gfp-wait", "N", true},
	    {"/sys/kernel/debug/fail_futex/ignore-private", "N", false},
	    {"/sys/kernel/debug/fail_page_alloc/ignore-gfp-highmem", "N", false},
	    {"/sys/kernel/debug/fail_page_alloc/ignore-gfp-wait", "N", false},
	    {"/sys/kernel/debug/fail_page_alloc/min-order", "0", false},
	};
	unsigned i;
	for (i = 0; i < sizeof(files) / sizeof(files[0]); i++) {
		if (!write_file(files[i].file, files[i].val)) {
			if (files[i].fatal)
	exit(1);
		}
	}
}

static void setup_sysctl()
{
	static struct {
		const char* name;
		const char* data;
	} files[] = {
	    {"/sys/kernel/debug/x86/nmi_longest_ns", "10000000000"},
	    {"/proc/sys/kernel/hung_task_check_interval_secs", "20"},
	    {"/proc/sys/net/core/bpf_jit_enable", "1"},
	    {"/proc/sys/net/core/bpf_jit_kallsyms", "1"},
	    {"/proc/sys/net/core/bpf_jit_harden", "0"},
	    {"/proc/sys/kernel/kptr_restrict", "0"},
	    {"/proc/sys/kernel/softlockup_all_cpu_backtrace", "1"},
	    {"/proc/sys/fs/mount-max", "100"},
	    {"/proc/sys/vm/oom_dump_tasks", "0"},
	    {"/proc/sys/debug/exception-trace", "0"},
	    {"/proc/sys/kernel/printk", "7 4 1 3"},
	    {"/proc/sys/net/ipv4/ping_group_range", "0 65535"},
	    {"/proc/sys/kernel/keys/gc_delay", "1"},
	    {"/proc/sys/vm/nr_overcommit_hugepages", "4"},
	    {"/proc/sys/vm/oom_kill_allocating_task", "1"},
	};
	for (size_t i = 0; i < sizeof(files) / sizeof(files[0]); i++) {
		if (!write_file(files[i].name, files[i].data))
			printf("write to %s failed: %s\n", files[i].name, strerror(errno));
	}
}

int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	inject_fault(0);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	setup_sysctl();
	setup_fault();
				syscall(__NR_madvise, 0x20ffd000ul, 0x3000ul, 0xcul);
	inject_fault(0);
	syscall(__NR_madvise, 0x20ffc000ul, 0x4000ul, 0xcul);
	return 0;
}
